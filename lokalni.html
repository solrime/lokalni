<!DOCTYPE html>
<html>
  <head>
    <title>AR Portal with Camera-Facing Sculpture</title>
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <script>
      // Register custom portal shader
      AFRAME.registerShader('portal', {
        schema: {
          color: { type: 'color', default: '#FFF' },
          timeMsec: { type: 'time', is: 'uniform' }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float timeMsec;
          varying vec2 vUv;
          void main() {
            float time = timeMsec / 1000.0;
            vec2 uv = vUv * 2.0 - 1.0;
            float radius = length(uv);
            float angle = atan(uv.y, uv.x);
            float distort = sin(angle * 5.0 + time * 2.0) * 0.1;
            uv += distort;
            vec3 color = vec3(sin(uv.x * 10.0 + time), cos(uv.y * 10.0 + time), sin(uv.x * uv.y * 10.0 + time));
            gl_FragColor = vec4(color, 1.0);
          }
        `
      });

      // Component to make entity always face camera
      AFRAME.registerComponent('look-at-camera', {
        schema: {
          type: 'selector',
          default: '[camera]'
        },
        init: function () {
          this.camera = document.querySelector(this.data) || this.el.sceneEl.camera.el;
        },
        tick: function () {
          if (!this.camera) return;
          
          const cameraPos = this.camera.object3D.position;
          const objectPos = this.el.object3D.position;
          
          // Calculate direction vector from object to camera
          const direction = new THREE.Vector3();
          direction.subVectors(cameraPos, objectPos);
          
          // Calculate rotation to face camera
          const targetRotation = new THREE.Euler();
          targetRotation.setFromRotationMatrix(
            new THREE.Matrix4().lookAt(objectPos, cameraPos, this.el.object3D.up)
          );
          
          // Apply rotation only on Y axis (horizontal rotation)
          this.el.object3D.rotation.y = targetRotation.y;
        }
      });
    </script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      .info-panel {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        max-width: 300px;
      }
    </style>
  </head>
  <body>
    <div class="info-panel">
      <h3>AR Portal with Camera-Facing Sculpture</h3>
      <p>Point your camera at the marker to see the portal and sculpture.</p>
      <p>The sculpture will always face your camera as you move around.</p>
    </div>
    
    <a-scene embedded arjs="patternRatio: 0.80">
      <a-marker type="pattern" url="https://raw.githubusercontent.com/solrime/lokalni/refs/heads/main/pattern-adobe-express-qr-code%20(13).patt">
        <!-- Portal effect -->
        <a-circle 
          position="0 0.5 0" 
          radius="0.5" 
          shader="portal"
          rotation="-90 0 0">
        </a-circle>
        
        <!-- Sculpture that always faces camera -->
        <a-entity
          gltf-model="url(https://cdn.tinyglb.com/models/35282dbf5d3f49878a1f49979bc1b64c.glb)"
          position="0 0.5 0" 
          scale="0.5 0.5 0.5"
          rotation="0 0 0"
          material="opacity: 0; transparent: true"
          look-at-camera
        ></a-entity>
      </a-marker>
      <a-entity camera></a-entity>
    </a-scene>
  </body>
</html>